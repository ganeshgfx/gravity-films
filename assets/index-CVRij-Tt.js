import{P as S,Q as P,y as G}from"./index-uYyiPXOa.js";const W=0,q=1,J=/(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi;function K(e,t,o){const{svgData:a}=e;if(!a)return"";const r=G(t,o);if(a.includes("fill"))return a.replace(J,()=>r);const i=a.indexOf(">");return`${a.substring(W,i)} fill="${r}"${a.substring(i)}`}async function D(e){return new Promise(t=>{e.loading=!0;const o=new Image;e.element=o,o.addEventListener("load",()=>{e.loading=!1,t()}),o.addEventListener("error",()=>{e.element=void 0,e.error=!0,e.loading=!1,S().error(`${P} loading image: ${e.source}`),t()}),o.src=e.source})}async function X(e){if(e.type!=="svg"){await D(e);return}e.loading=!0;const t=await fetch(e.source);t.ok?e.svgData=await t.text():(S().error(`${P} Image not found`),e.error=!0),e.loading=!1}function Y(e,t,o,a){var n;const r=K(e,o,((n=a.opacity)==null?void 0:n.value)??q),i={color:o,gif:t.gif,data:{...e,svgData:r},loaded:!1,ratio:t.width/t.height,replaceColor:t.replaceColor,source:t.src};return new Promise(l=>{const d=new Blob([r],{type:"image/svg+xml"}),g=URL||window.URL||window.webkitURL||window,c=g.createObjectURL(d),u=new Image;u.addEventListener("load",()=>{i.loaded=!0,i.element=u,l(i),g.revokeObjectURL(c)});const C=async()=>{g.revokeObjectURL(c);const I={...e,error:!1,loading:!0};await D(I),i.loaded=!0,i.element=I.element,l(i)};u.addEventListener("error",()=>void C()),u.src=c})}const F=[0,4,2,1],_=[8,8,4,2];class Z{constructor(t){this.pos=0,this.data=new Uint8ClampedArray(t)}getString(t){const o=this.data.slice(this.pos,this.pos+t);return this.pos+=o.length,o.reduce((a,r)=>a+String.fromCharCode(r),"")}nextByte(){return this.data[this.pos++]}nextTwoBytes(){return this.pos+=2,this.data[this.pos-2]+(this.data[this.pos-1]<<8)}readSubBlocks(){let t="",o=0;const a=0,r=0;do{o=this.data[this.pos++];for(let i=o;--i>=a;t+=String.fromCharCode(this.data[this.pos++]));}while(o!==r);return t}readSubBlocksBin(){let t=this.data[this.pos],o=0;const a=0,r=1;for(let n=0;t!==a;n+=t+r,t=this.data[this.pos+n])o+=t;const i=new Uint8Array(o);t=this.data[this.pos++];for(let n=0;t!==a;t=this.data[this.pos++])for(let l=t;--l>=a;i[n++]=this.data[this.pos++]);return i}skipSubBlocks(){for(const t=1,o=0;this.data[this.pos]!==o;this.pos+=this.data[this.pos]+t);this.pos++}}var y;(function(e){e[e.Replace=0]="Replace",e[e.Combine=1]="Combine",e[e.RestoreBackground=2]="RestoreBackground",e[e.RestorePrevious=3]="RestorePrevious",e[e.UndefinedA=4]="UndefinedA",e[e.UndefinedB=5]="UndefinedB",e[e.UndefinedC=6]="UndefinedC",e[e.UndefinedD=7]="UndefinedD"})(y||(y={}));var k;(function(e){e[e.Extension=33]="Extension",e[e.ApplicationExtension=255]="ApplicationExtension",e[e.GraphicsControlExtension=249]="GraphicsControlExtension",e[e.PlainTextExtension=1]="PlainTextExtension",e[e.CommentExtension=254]="CommentExtension",e[e.Image=44]="Image",e[e.EndOfFile=59]="EndOfFile"})(k||(k={}));const w={x:0,y:0},V=0,z=.5,M=0,$=0,O=0;function j(e,t){const o=[];for(let a=0;a<t;a++)o.push({r:e.data[e.pos],g:e.data[e.pos+1],b:e.data[e.pos+2]}),e.pos+=3;return o}function H(e,t,o,a){switch(e.nextByte()){case k.GraphicsControlExtension:{const r=t.frames[o(!1)];e.pos++;const i=e.nextByte();r.GCreserved=(i&224)>>>5,r.disposalMethod=(i&28)>>>2,r.userInputDelayFlag=(i&2)===2;const n=(i&1)===1;r.delayTime=e.nextTwoBytes()*10;const l=e.nextByte();n&&a(l),e.pos++;break}case k.ApplicationExtension:{e.pos++;const r={identifier:e.getString(8),authenticationCode:e.getString(3),data:e.readSubBlocksBin()};t.applicationExtensions.push(r);break}case k.CommentExtension:{t.comments.push([o(!1),e.readSubBlocks()]);break}case k.PlainTextExtension:{if(t.globalColorTable.length===0)throw new EvalError("plain text extension without global color table");e.pos++,t.frames[o(!1)].plainTextData={left:e.nextTwoBytes(),top:e.nextTwoBytes(),width:e.nextTwoBytes(),height:e.nextTwoBytes(),charSize:{width:e.nextTwoBytes(),height:e.nextTwoBytes()},foregroundColor:e.nextByte(),backgroundColor:e.nextByte(),text:e.readSubBlocks()};break}default:e.skipSubBlocks();break}}async function ee(e,t,o,a,r,i){const n=t.frames[a(!0)];n.left=e.nextTwoBytes(),n.top=e.nextTwoBytes(),n.width=e.nextTwoBytes(),n.height=e.nextTwoBytes();const l=e.nextByte(),d=(l&128)===128,g=(l&64)===64;n.sortFlag=(l&32)===32,n.reserved=(l&24)>>>3;const c=1<<(l&7)+1;d&&(n.localColorTable=j(e,c));const u=f=>{const{r:h,g:m,b:s}=(d?n.localColorTable:t.globalColorTable)[f];return f!==r(null)?{r:h,g:m,b:s,a:255}:{r:h,g:m,b:s,a:o?~~((h+m+s)/3):0}},C=(()=>{try{return new ImageData(n.width,n.height,{colorSpace:"srgb"})}catch(f){if(f instanceof DOMException&&f.name==="IndexSizeError")return null;throw f}})();if(C==null)throw new EvalError("GIF frame size is to large");const I=e.nextByte(),L=e.readSubBlocksBin(),x=1<<I,v=(f,h)=>{const m=f>>>3,s=f&7;return(L[m]+(L[m+1]<<8)+(L[m+2]<<16)&(1<<h)-1<<s)>>>s};if(g){for(let f=0,h=I+1,m=0,s=[[0]],B=0;B<4;B++)if(F[B]<n.height){let p=0,E=0,b=!1;for(;!b;){const R=f;if(f=v(m,h),m+=h+1,f===x){h=I+1,s.length=x+2;for(let T=0;T<s.length;T++)s[T]=T<x?[T]:[]}else{f>=s.length?s.push(s[R].concat(s[R][0])):R!==x&&s.push(s[R].concat(s[f][0]));for(const T of s[f]){const{r:U,g:A,b:N,a:Q}=u(T);C.data.set([U,A,N,Q],F[B]*n.width+_[B]*E+p%(n.width*4)),p+=4}s.length===1<<h&&h<12&&h++}p===n.width*4*(E+1)&&(E++,F[B]+_[B]*E>=n.height&&(b=!0))}}n.image=C,n.bitmap=await createImageBitmap(C)}else{let f=0,h=I+1,m=0,s=-4,B=!1;const p=[[0]];for(;!B;){const E=f;if(f=v(m,h),m+=h,f===x){h=I+1,p.length=x+2;for(let b=0;b<p.length;b++)p[b]=b<x?[b]:[]}else{if(f===x+1){B=!0;break}f>=p.length?p.push(p[E].concat(p[E][0])):E!==x&&p.push(p[E].concat(p[f][0]));for(const b of p[f]){const{r:R,g:T,b:U,a:A}=u(b);C.data.set([R,T,U,A],s+=4)}p.length>=1<<h&&h<12&&h++}}n.image=C,n.bitmap=await createImageBitmap(C)}}async function te(e,t,o,a,r,i){switch(e.nextByte()){case k.EndOfFile:return!0;case k.Image:await ee(e,t,o,a,r);break;case k.Extension:H(e,t,a,r);break;default:throw new EvalError("undefined block found")}return!1}function oe(e){for(const t of e.applicationExtensions)if(t.identifier+t.authenticationCode==="NETSCAPE2.0")return t.data[1]+(t.data[2]<<8);return NaN}async function ne(e,t,o){o||(o=!1);const a=await fetch(e);if(!a.ok&&a.status===404)throw new EvalError("file not found");const r=await a.arrayBuffer(),i={width:0,height:0,totalTime:0,colorRes:0,pixelAspectRatio:0,frames:[],sortFlag:!1,globalColorTable:[],backgroundImage:new ImageData(1,1,{colorSpace:"srgb"}),comments:[],applicationExtensions:[]},n=new Z(new Uint8ClampedArray(r));if(n.getString(6)!=="GIF89a")throw new Error("not a supported GIF file");i.width=n.nextTwoBytes(),i.height=n.nextTwoBytes();const l=n.nextByte(),d=(l&128)===128;i.colorRes=(l&112)>>>4,i.sortFlag=(l&8)===8;const g=1<<(l&7)+1,c=n.nextByte();i.pixelAspectRatio=n.nextByte(),i.pixelAspectRatio!==0&&(i.pixelAspectRatio=(i.pixelAspectRatio+15)/64),d&&(i.globalColorTable=j(n,g));const u=(()=>{try{return new ImageData(i.width,i.height,{colorSpace:"srgb"})}catch(s){if(s instanceof DOMException&&s.name==="IndexSizeError")return null;throw s}})();if(u==null)throw new Error("GIF frame size is to large");const{r:C,g:I,b:L}=i.globalColorTable[c];u.data.set(d?[C,I,L,255]:[0,0,0,0]);for(let s=4;s<u.data.length;s*=2)u.data.copyWithin(s,0,s);i.backgroundImage=u;let x=-1,v=!0,f=-1;const h=s=>(s&&(v=!0),x),m=s=>(s!=null&&(f=s),f);try{do v&&(i.frames.push({left:0,top:0,width:0,height:0,disposalMethod:y.Replace,image:new ImageData(1,1,{colorSpace:"srgb"}),plainTextData:null,userInputDelayFlag:!1,delayTime:0,sortFlag:!1,localColorTable:[],reserved:0,GCreserved:0}),x++,f=-1,v=!1);while(!await te(n,i,o,h,m,t));i.frames.length--;for(const s of i.frames){if(s.userInputDelayFlag&&s.delayTime===0){i.totalTime=1/0;break}i.totalTime+=s.delayTime}return i}catch(s){throw s instanceof EvalError?new Error(`error while parsing frame ${x} "${s.message}"`):s}}function ie(e){const{context:t,radius:o,particle:a,delta:r}=e,i=a.image;if(!(i!=null&&i.gifData)||!i.gif)return;const n=new OffscreenCanvas(i.gifData.width,i.gifData.height),l=n.getContext("2d");if(!l)throw new Error("could not create offscreen canvas context");l.imageSmoothingQuality="low",l.imageSmoothingEnabled=!1,l.clearRect(w.x,w.y,n.width,n.height),a.gifLoopCount===void 0&&(a.gifLoopCount=i.gifLoopCount??O);let d=a.gifFrame??V;const g={x:-i.gifData.width*z,y:-i.gifData.height*z},c=i.gifData.frames[d];if(a.gifTime===void 0&&(a.gifTime=M),!!c.bitmap){switch(t.scale(o/i.gifData.width,o/i.gifData.height),c.disposalMethod){case y.UndefinedA:case y.UndefinedB:case y.UndefinedC:case y.UndefinedD:case y.Replace:l.drawImage(c.bitmap,c.left,c.top),t.drawImage(n,g.x,g.y),l.clearRect(w.x,w.y,n.width,n.height);break;case y.Combine:l.drawImage(c.bitmap,c.left,c.top),t.drawImage(n,g.x,g.y);break;case y.RestoreBackground:l.drawImage(c.bitmap,c.left,c.top),t.drawImage(n,g.x,g.y),l.clearRect(w.x,w.y,n.width,n.height),i.gifData.globalColorTable.length?l.putImageData(i.gifData.backgroundImage,g.x,g.y):l.putImageData(i.gifData.frames[$].image,g.x+c.left,g.y+c.top);break;case y.RestorePrevious:{const u=l.getImageData(w.x,w.y,n.width,n.height);l.drawImage(c.bitmap,c.left,c.top),t.drawImage(n,g.x,g.y),l.clearRect(w.x,w.y,n.width,n.height),l.putImageData(u,w.x,w.y)}break}if(a.gifTime+=r.value,a.gifTime>c.delayTime){if(a.gifTime-=c.delayTime,++d>=i.gifData.frames.length){if(--a.gifLoopCount<=O)return;d=$,l.clearRect(w.x,w.y,n.width,n.height)}a.gifFrame=d}t.scale(i.gifData.width/o,i.gifData.height/o)}}async function ae(e){if(e.type!=="gif"){await D(e);return}e.loading=!0;try{e.gifData=await ne(e.source),e.gifLoopCount=oe(e.gifData)??O,e.gifLoopCount||(e.gifLoopCount=1/0)}catch{e.error=!0}e.loading=!1}const re=2,se=1,le=12,ce=1;class fe{constructor(t){this.validTypes=["image","images"],this.loadImageShape=async o=>{if(!this._engine.loadImage)throw new Error(`${P} image shape not initialized`);await this._engine.loadImage({gif:o.gif,name:o.name,replaceColor:o.replaceColor??!1,src:o.src})},this._engine=t}addImage(t){this._engine.images||(this._engine.images=[]),this._engine.images.push(t)}draw(t){const{context:o,radius:a,particle:r,opacity:i}=t,n=r.image,l=n==null?void 0:n.element;if(n){if(o.globalAlpha=i,n.gif&&n.gifData)ie(t);else if(l){const d=n.ratio,g={x:-a,y:-a},c=a*re;o.drawImage(l,g.x,g.y,c,c/d)}o.globalAlpha=se}}getSidesCount(){return le}async init(t){const o=t.actualOptions;if(!(!o.preload||!this._engine.loadImage))for(const a of o.preload)await this._engine.loadImage(a)}loadShape(t){if(t.shape!=="image"&&t.shape!=="images")return;this._engine.images||(this._engine.images=[]);const o=t.shapeData;if(!o)return;this._engine.images.find(r=>r.name===o.name||r.source===o.src)||this.loadImageShape(o).then(()=>{this.loadShape(t)})}particleInit(t,o){if(o.shape!=="image"&&o.shape!=="images")return;this._engine.images||(this._engine.images=[]);const a=this._engine.images,r=o.shapeData;if(!r)return;const i=o.getFillColor(),n=a.find(d=>d.name===r.name||d.source===r.src);if(!n)return;const l=r.replaceColor??n.replaceColor;if(n.loading){setTimeout(()=>{this.particleInit(t,o)});return}(async()=>{let d;n.svgData&&i?d=await Y(n,r,i,o):d={color:i,data:n,element:n.element,gif:n.gif,gifData:n.gifData,gifLoopCount:n.gifLoopCount,loaded:!0,ratio:r.width&&r.height?r.width/r.height:n.ratio??ce,replaceColor:l,source:r.src},d.ratio||(d.ratio=1);const g=r.fill??o.shapeFill,c=r.close??o.shapeClose,u={image:d,fill:g,close:c};o.image=u.image,o.shapeFill=u.fill,o.shapeClose=u.close})()}}class ge{constructor(){this.src="",this.gif=!1}load(t){t&&(t.gif!==void 0&&(this.gif=t.gif),t.height!==void 0&&(this.height=t.height),t.name!==void 0&&(this.name=t.name),t.replaceColor!==void 0&&(this.replaceColor=t.replaceColor),t.src!==void 0&&(this.src=t.src),t.width!==void 0&&(this.width=t.width))}}class de{constructor(t){this.id="imagePreloader",this._engine=t}async getPlugin(){return await Promise.resolve(),{}}loadOptions(t,o){if(!(o!=null&&o.preload))return;t.preload||(t.preload=[]);const a=t.preload;for(const r of o.preload){const i=a.find(n=>n.name===r.name||n.src===r.src);if(i)i.load(r);else{const n=new ge;n.load(r),a.push(n)}}}needsPlugin(){return!0}}const he=3;function ue(e){e.loadImage||(e.loadImage=async t=>{if(!t.name&&!t.src)throw new Error(`${P} no image source provided`);if(e.images||(e.images=[]),!e.images.find(o=>o.name===t.name||o.source===t.src))try{const o={gif:t.gif??!1,name:t.name??t.src,source:t.src,type:t.src.substring(t.src.length-he),error:!1,loading:!0,replaceColor:t.replaceColor,ratio:t.width&&t.height?t.width/t.height:void 0};e.images.push(o);let a;t.gif?a=ae:a=t.replaceColor?X:D,await a(o)}catch{throw new Error(`${P} ${t.name??t.src} not found`)}})}async function me(e,t=!0){ue(e);const o=new de(e);await e.addPlugin(o,t),await e.addShape(new fe(e),t)}export{me as loadImageShape};
