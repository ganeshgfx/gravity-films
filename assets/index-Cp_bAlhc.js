import{F as r,T as f,W as o,S as l,G as s,X as d,L as c,Y as h,Z as m}from"./index-CR-cpxNI.js";class y{constructor(){this.enable=!1,this.speed=0,this.decay=0,this.sync=!1}load(e){e&&(e.enable!==void 0&&(this.enable=e.enable),e.speed!==void 0&&(this.speed=r(e.speed)),e.decay!==void 0&&(this.decay=r(e.decay)),e.sync!==void 0&&(this.sync=e.sync))}}class b extends f{constructor(){super(),this.animation=new y,this.direction=o.clockwise,this.path=!1,this.value=0}load(e){e&&(super.load(e),e.direction!==void 0&&(this.direction=e.direction),this.animation.load(e.animation),e.path!==void 0&&(this.path=e.path))}}const u=2,w=Math.PI*u,R=1,g=360;class v{constructor(e){this.container=e}init(e){const t=e.options.rotate;if(!t)return;e.rotate={enable:t.animation.enable,value:l(s(t.value)),min:0,max:w},e.pathRotation=t.path;let n=t.direction;switch(n===o.random&&(n=Math.floor(c()*u)>0?o.counterClockwise:o.clockwise),n){case o.counterClockwise:case"counterClockwise":e.rotate.status=d.decreasing;break;case o.clockwise:e.rotate.status=d.increasing;break}const a=t.animation;a.enable&&(e.rotate.decay=R-s(a.decay),e.rotate.velocity=s(a.speed)/g*this.container.retina.reduceFactor,a.sync||(e.rotate.velocity*=c())),e.rotation=e.rotate.value}isEnabled(e){const t=e.options.rotate;return t?!e.destroyed&&!e.spawning&&(!!t.value||t.animation.enable||t.path):!1}loadOptions(e,...t){e.rotate||(e.rotate=new b);for(const n of t)e.rotate.load(n==null?void 0:n.rotate)}update(e,t){this.isEnabled(e)&&(e.isRotating=!!e.rotate,e.rotate&&(h(e,e.rotate,!1,m.none,t),e.rotation=e.rotate.value))}}async function I(i,e=!0){await i.addParticleUpdater("rotate",t=>Promise.resolve(new v(t)),e)}export{I as loadRotateUpdater};
