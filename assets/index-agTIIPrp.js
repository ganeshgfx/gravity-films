import{x as C,v as b,y as g,c as P,z as R,d as k}from"./index-CR-cpxNI.js";import{E as w}from"./ExternalInteractorBase-BIfZtfad.js";class S{constructor(){this.opacity=.5}load(t){t&&t.opacity!==void 0&&(this.opacity=t.opacity)}}class O{constructor(){this.distance=80,this.links=new S,this.radius=60}load(t){t&&(t.distance!==void 0&&(this.distance=t.distance),this.links.load(t.links),t.radius!==void 0&&(this.radius=t.radius))}}const h=0,m=1,E=0;function D(e,t,n,i){const o=Math.floor(n.getRadius()/t.getRadius()),s=t.getFillColor(),r=n.getFillColor();if(!s||!r)return;const d=t.getPosition(),a=n.getPosition(),l=b(s,r,t.getRadius(),n.getRadius()),c=e.createLinearGradient(d.x,d.y,a.x,a.y);return c.addColorStop(h,g(s,i)),c.addColorStop(P(o,h,m),R(l,i)),c.addColorStop(m,g(r,i)),c}function L(e,t,n,i,o){C(e,i,o),e.lineWidth=t,e.strokeStyle=n,e.stroke()}function F(e,t,n,i){const o=e.actualOptions,s=o.interactivity.modes.connect;if(s)return D(t,n,i,s.links.opacity)}function H(e,t,n){e.canvas.draw(i=>{const o=F(e,i,t,n);if(!o)return;const s=t.getPosition(),r=n.getPosition();L(i,t.retina.linksWidth??E,o,s,r)})}const I="connect",v=0;class q extends w{constructor(t){super(t)}clear(){}init(){const t=this.container,n=t.actualOptions.interactivity.modes.connect;n&&(t.retina.connectModeDistance=n.distance*t.retina.pixelRatio,t.retina.connectModeRadius=n.radius*t.retina.pixelRatio)}interact(){const t=this.container;if(t.actualOptions.interactivity.events.onHover.enable&&t.interactivity.status==="pointermove"){const i=t.interactivity.mouse.position,{connectModeDistance:o,connectModeRadius:s}=t.retina;if(!o||o<v||!s||s<v||!i)return;const r=Math.abs(s),d=t.particles.quadTree.queryCircle(i,r,a=>this.isEnabled(a));d.forEach((a,l)=>{const c=a.getPosition(),p=1;for(const u of d.slice(l+p)){const f=u.getPosition(),y=Math.abs(o),M=Math.abs(c.x-f.x),x=Math.abs(c.y-f.y);M<y&&x<y&&H(t,a,u)}})}}isEnabled(t){const n=this.container,i=n.interactivity.mouse,o=((t==null?void 0:t.interactivity)??n.actualOptions.interactivity).events;return o.onHover.enable&&i.position?k(I,o.onHover.mode):!1}loadModeOptions(t,...n){t.connect||(t.connect=new O);for(const i of n)t.connect.load(i==null?void 0:i.connect)}reset(){}}async function A(e,t=!0){await e.addInteractor("externalConnect",n=>Promise.resolve(new q(n)),t)}export{O as Connect,S as ConnectLinks,A as loadExternalConnectInteraction};
